<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>【学习向 】mysql基础知识整理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近面试问了一道sql的题，觉得有意思，就花了一段时间学习了sql语言。在此分享自己的学习感悟和学习笔记 一，学习材料 学习资料和演示代码集合学习资料 学习视频学习视频二，学习笔记这段时间的学习笔记，按视频的顺序来整理的。在资料里面有个测试.sql里面就有我的笔记，也可以从里面自己看。#基础查询/*select 查询列表 from 表名类似于：system.out.println（打印东西）列表可">
<meta property="og:type" content="article">
<meta property="og:title" content="【学习向 】mysql基础知识整理">
<meta property="og:url" content="http://yoursite.com/2019/08/22/4day/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近面试问了一道sql的题，觉得有意思，就花了一段时间学习了sql语言。在此分享自己的学习感悟和学习笔记 一，学习材料 学习资料和演示代码集合学习资料 学习视频学习视频二，学习笔记这段时间的学习笔记，按视频的顺序来整理的。在资料里面有个测试.sql里面就有我的笔记，也可以从里面自己看。#基础查询/*select 查询列表 from 表名类似于：system.out.println（打印东西）列表可">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-22T03:03:59.637Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【学习向 】mysql基础知识整理">
<meta name="twitter:description" content="最近面试问了一道sql的题，觉得有意思，就花了一段时间学习了sql语言。在此分享自己的学习感悟和学习笔记 一，学习材料 学习资料和演示代码集合学习资料 学习视频学习视频二，学习笔记这段时间的学习笔记，按视频的顺序来整理的。在资料里面有个测试.sql里面就有我的笔记，也可以从里面自己看。#基础查询/*select 查询列表 from 表名类似于：system.out.println（打印东西）列表可">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-4day" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/22/4day/" class="article-date">
  <time datetime="2019-08-22T02:57:13.311Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【学习向 】mysql基础知识整理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近面试问了一道sql的题，觉得有意思，就花了一段时间学习了sql语言。在此分享自己的学习感悟和学习笔记</p>
<h2 id="一，学习材料"><a href="#一，学习材料" class="headerlink" title="一，学习材料"></a>一，学习材料</h2><ol>
<li>学习资料和演示代码集合<br><a href="https://download.csdn.net/download/waq250/11591971" target="_blank" rel="noopener">学习资料</a></li>
<li>学习视频<br><a href="https://b23.tv/av59623481/p1" target="_blank" rel="noopener">学习视频</a><h2 id="二，学习笔记"><a href="#二，学习笔记" class="headerlink" title="二，学习笔记"></a>二，学习笔记</h2>这段时间的学习笔记，按视频的顺序来整理的。在资料里面有个测试.sql里面就有我的笔记，也可以从里面自己看。<br>#基础查询<br>/*<br>select 查询列表 from 表名<br>类似于：system.out.println（打印东西）<br>列表可以是变量值，函数，表达式，字段<br>查询结果是一个虚拟的表格</li>
</ol>
<p>*/<br>USE myemplyees;</p>
<p>#查询单个字段<br>SELECT last_name FROM employees;</p>
<p>#查询多个字段<br>SELECT last_name,email FROM employees;</p>
<p>#查询所有字段<br>SELECT * FROM employees;</p>
<p>#查询常量值<br>SELECT 100;<br>SELECT ‘jjkk’;</p>
<p>#查询表达式<br>SELECT 100%98;</p>
<p>#查询函数名<br>SELECT VERSION();</p>
<p>#起别名<br>/*<br>1,便于理解<br>2，有重名，别名可以区分<br>*/<br>SELECT last_name AS 姓 FROM employees;<br>SELECT last_name 姓 FROM employees;<br>SELECT last_name AS “out put” FROM employees;#别名有关键字</p>
<p>#查询涉及的部门编号<br>SELECT department_id FROM employees;<br>SELECT DISTINCT department_id FROM employees;#去重<br>/*<br>+号作用<br>java中<br>1，运算符<br>2，连接符，只要其中一个为字符串<br>mysql中+号作用：<br>运算符<br>select 100+90;<br>select ‘100’+90;其中一方为字符型，试图先将其转成数值型，再做加法运算<br>select ‘ss’+90;转化失败，则将字符型数值转成0<br>select null+90;只要一方为null，输出就位null<br>*/</p>
<p>#案例，查询员工和姓连接一个字段<br>SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees;#concat 拼接</p>
<p> #条件查询<br> /*<br> 语法：<br> select<br>      查询列表  3//筛选顺序<br> from<br>      表名     1<br> where<br>      筛选条件 （if）    2<br> 分类：<br> 一，按条件表达式筛选<br> 条件运算符：&lt;&gt;= !=<br> 二，逻辑运算符<br> &amp;&amp;|| !<br> and or not<br> 三，模糊查询<br> like<br> between and<br> in<br> is null<br> */</p>
<p> #查询工资&gt;12000的员工信息<br> SELECT  *<br> FROM<br> employees<br> WHERE<br> salary&gt;12000;</p>
<p> #查询部门编号不等于90的的1员工名和部门编号&lt;&gt;<br> SELECT<br> <code>first_name</code>,<code>department_id</code><br> FROM<br> employees<br> WHERE<br> department_id!=90;</p>
<p> #查询部门编号40到90之间的员工名和部门编号&lt;&gt;<br>  SELECT<br> <code>first_name</code>,<code>department_id</code><br> FROM<br> employees<br> WHERE<br> department_id&gt;=40<br> AND<br>  department_id&lt;=90;<br>  三，模糊查询<br>  /*<br> like<br> 一般搭配通配符使用，可以判断字符型或数值型<br> 通配符：%任意多个字符，_任意单个字符<br> between and<br> 1,提高简洁渡<br> 2，包含临界值<br> 3，不能颠倒顺序<br> in<br> 判断字段的值是否属于in列表的某一项<br> 1，使用in提高简洁渡<br> 2in列表的值类型必须统一或兼容<br> is null<br> =&lt;&gt;不能判断null值<br> is not 和null搭配<br> */</p>
<p> #1.like</p>
<p> #查询员工包含a字符的员工信息<br>  SELECT  *<br> FROM<br> employees<br> WHERE<br> last_name LIKE ‘%a%’;</p>
<p> #查询员工包含第三个字符为n字符第五个为l的员工信息<br> SELECT  *<br> FROM<br> employees<br> WHERE<br> last_name LIKE ‘__n_l%’;#一个下划线是一个空格</p>
<p>  #查询员工包含第二个字符是<em>的员工信息<br>   SELECT *<br> FROM<br> employees<br> WHERE<br> last_name LIKE ‘</em>$_%’ ESCAPE ‘$’;#把$作为转义符</p>
<p> #查询数值型的部门编号100以上的值<br>SELECT  *<br> FROM<br> employees<br> WHERE<br> department_id LIKE ‘1__’;</p>
<p> #2,between and</p>
<p> #查询部门编号40到90之间的员工名和部门编号&lt;&gt;<br>   SELECT<br> <code>first_name</code>,<code>department_id</code><br> FROM<br> employees<br> WHERE<br> department_id&gt;=40<br> AND<br>  department_id&lt;=90;</p>
<p>  #———————————-<br>  SELECT<br> <code>first_name</code>,<code>department_id</code><br> FROM<br> employees<br> WHERE<br> department_id<br> BETWEEN<br> 40<br> AND<br> 90;</p>
<p> #3，in</p>
<p> #查询工种名是AD_VP,AD_PRES的员工所有信息<br> SELECT *<br> FROM<br> employees<br> WHERE<br> job_id=’AD_VP’OR job_id=’AD_PRES’;</p>
<p> #——————–<br>  SELECT  *<br> FROM<br> employees<br> WHERE<br> job_id IN (‘AD_VP’,’AD_PRES’);</p>
<p> #4，is null</p>
<p> #查询没有奖金的人员所有信息<br>  SELECT *<br> FROM<br> employees<br> WHERE<br> commission_pct IS NULL;# commission_pct = NULL是错误写法</p>
<p>  #查询有奖金的人员所有信息<br>  SELECT  *<br> FROM<br> employees<br> WHERE<br> commission_pct IS NOT NULL;# commission_pct = NULL是错误写法</p>
<p>  #安全等于&lt;=&gt; 就是等于的意思</p>
<p>  #查询没有奖金的人员所有信息<br>  SELECT  *<br> FROM<br> employees<br> WHERE<br> commission_pct &lt;=&gt; NULL;# commission_pct = NULL是错误写法</p>
<p> #is null pk &lt;=&gt;<br> /*<br> is null:仅仅判断null值，可读性好<br> &lt;=&gt;:既可以判断null值。又可以判断普通的数值，可读性差<br> //计算年薪：<br> salary<em>12</em>(1+ifnull(commission_pct,0)):ifnull判断是否为null，是则转为0<br> */</p>
<p>  #判断commission_pct是否为null，是则返回1<br> SELECT ISNULL(commission_pct),commission_pct FROM employees;</p>
<p> #排序查询<br> /*<br> 语法：<br> select 查询列表               3<br> from  表                1<br> 【where筛选条件】              2<br> order by 排序列表【asc|desc】升序|降序 4<br> 特点：<br> asc升序，desc降序<br> 什么都不写<br> 默认是升序<br> 2,order by 子句中可以支持单个字段，多个字段，表达式，函数，别名<br> 3，order by 子句一般放在查询语句的最后面，除了limit子句除外<br> */</p>
<p> #查询员工信息，要求工资从高到低<br> SELECT  *<br> FROM<br> employees<br> ORDER BY<br> salary DESC;</p>
<p>  #查询员工信息，要求部门编号&gt;=90，按入职时间排序<br> SELECT  *<br> FROM<br> employees<br> WHERE<br> department_id&gt;=90<br> ORDER BY<br> hiredate ASC;</p>
<p> #按年薪高低显示员工的信息和年薪【按表达式排序】<br>  SELECT<br> <em>,salary*12</em>(1+IFNULL(commission_pct,0)) AS 年薪<br> FROM<br> employees<br> ORDER BY<br>salary<em>12</em>(1+IFNULL(commission_pct,0)) ASC;</p>
<p> #按年薪高低显示员工的信息和年薪【按别名排序】<br>  SELECT<br> <em>,salary*12</em>(1+IFNULL(commission_pct,0)) AS 年薪<br> FROM<br> employees<br> ORDER BY<br>“年薪” ASC;</p>
<p>#按姓名的长度显示员工的姓名和工资【按函数排序】<br> SELECT<br> LENGTH(last_name) AS 字节长度,last_name,salary<br> FROM<br> employees<br> ORDER BY<br>LENGTH(last_name) DESC;</p>
<p>#查询工信息，要求先按工资升序，再按员工编号降序【按多个字段排序】<br>  SELECT  *<br> FROM<br> employees<br> ORDER BY<br>salary ASC,employee_id DESC;#先按工资升序，再按员工编号降序</p>
<p>#4，常见函数<br>/*<br>概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名<br>好处，1：隐藏了实现细节<br>2，提高了代码的重用性<br>调用：select函数名（实参函数）【from 表】<br>特点：<br>叫什么<br>干什么<br>分类：<br>单行函数（会有返回值），输入一个数，输出一个值<br>分组函数 功能：做统计用的。输入一组数，输出一个值<br>*/</p>
<p>#一，字符函数</p>
<p>#1，length获取参数值字节个数<br>SELECT LENGTH (“张三丰hahaha”);#输出15，一个汉字三个字节<br>SHOW VARIABLES LIKE “%char%”;#查询客户端字符集：utf8汉字三个字节，jdk一个汉字二个字节</p>
<p>#2，concat 拼接字符串<br>SELECT CONCAT (last_name,’_’,first_name)AS 姓名 FROM employees;</p>
<p>#3,upper,lower<br>SELECT UPPER(“jok”);#变大写<br>SELECT LOWER (“JIo”);#变小写</p>
<p>#4，substr=substring<br>注意：索引从一开始</p>
<p>#截取从指定索引后面的字符<br>SELECT SUBSTR(“李莫愁爱上了路站元”,7)AS oueput;</p>
<p>#截取指定索引出指定长度的字符<br>SELECT SUBSTR(“李莫愁爱上了路站元”,1,3)AS ddd;</p>
<p>#5，instr 返回子串中第一次出现的索引，如果找不到就返回0<br>SELECT INSTR(“李莫愁爱上了路站元”,”路站元”)AS ddd;</p>
<p>#6 trim  去除前后制定的字符路站元”  输出：张aaaac催收<br>SELECT TRIM(‘a’FROM “aaaaaaaaaaaaa张aaaac催收aaaaaaaaa”) AS outl;</p>
<p>#7，lpad 左填充的字符实现左填充制定长度   <strong>***</strong>张小顺<br>SELECT LPAD(“张小顺”,10,’*’)AS ooo;</p>
<p>#8，rpad 右填充的字符实现左填充制定长度   张小顺<strong>***</strong><br>SELECT RPAD(“张小顺”,10,’*’)AS ooo;</p>
<p>#9，replace替换  ggggggggggccccccccbbb<br>SELECT REPLACE(“aaaaaaaaaaccccccccbbb”,’a’,’g’) AS opj</p>
<p>#二，数字函数</p>
<p>#round 四舍五入<br>SELECT ROUND(1.66);#2<br>SELECT ROUND(1.6678,2);#1.67</p>
<p>#ceil 向上取，返回&gt;=概参数最小整数</p>
<p>#floor 向下取整，返回&lt;=该参数的最大整数</p>
<p>#truncate 截断 1.79<br>SELECT TRUNCATE(1.799999,2);</p>
<p>#mod取余<br>/*<br>mod(a,b):a-a/b<em>b<br>mod(-10,-3):-10-(-10)/(-3)</em>(-3)=-1<br>*/</p>
<p>#三，日期函数</p>
<p>#now  返回当前系统日期+时间2019-08-08 10:27:45<br>SELECT NOW();</p>
<p>#curdate返回当前的日期不包含时间</p>
<p>#curtime 返回当前的时间不包含日期</p>
<p>#datadiff返回两个日期之差<br>SELECT DATEDIFF(NOW(),”1996-4-25”);#8505</p>
<p>#可以获取指定日期的年，月，日。分，秒，<br>SELECT YEAR(NOW()); #2019<br>SELECT YEAR(“1009-9-9”); #1009<br>SELECT YEAR(hiredate) AS nain FROM employees;<br>SELECT MONTH(NOW()); #8</p>
<p>#str_to_date将字符通过指定的格式转换成日期<br>SELECT * FROM employees WHERE hiredate =STR_TO_DATE(“4-3 1992”,”%c-%d %Y”);#用户输入4-3 1992查找</p>
<p>#date_format 将日期转换成字符<br>SELECT DATE_FORMAT(NOW(),”%y年/%m月/%d日”) AS ppp;</p>
<p>#四其他函数<br>SELECT VERSION();<br>SELECT DATABASE();#数据库<br>SELECT USER();#用户</p>
<p>#五，流程控制函数</p>
<p>#1，IF函数：<br>SELECT IF(10&lt;5,”大”,”小”);#第一个是条件，真的返回大，假的返回小</p>
<p>#2，CASE函数<br>/*<br>java中<br>switch(表达式或变量)<br>{<br>case 常量1： 语句;break;<br>…<br>default:语句n,break;<br>}<br>mysql中<br>case 要判断的字或表达式<br>when 常量1 then 要显示的值或语句；<br>。。。。<br>else 要显示的其他值或语句n;<br>end<br><em>/<br>/</em><br>查询部门的1员工工资<br>部门号=30，显示工资为为1.1<br>40为1.2<br>50为1.3<br>其余为原工资<br><em>/<br>SELECT salary AS 原工资,department_id,<br>CASE department_id<br>WHEN 30 THEN salary</em>1.1<br>WHEN 40 THEN salary<em>1.2<br>WHEN 50 THEN salary</em>1.3<br>ELSE salary<br>END AS 新工作<br>FROM employees;</p>
<p>#另一种用法 相当于多重if 区间<br>/*<br>case<br>when 条件1 then 要显示值或语句；<br>….<br>else 要显示值或语句；<br>end<br>*/</p>
<p>#案例显示工资级别<br>如果工资&gt;20000,显示A<br>如果工资&gt;15000,显示B<br>如果工资&gt;10000,显示C<br>否则为D<br>SELECT salary,<br>CASE<br>WHEN salary&gt;20000 THEN ‘A’<br>WHEN salary&gt;15000 THEN ‘B’<br>WHEN salary&gt;10000 THEN ‘C’<br>ELSE ‘D’<br>END AS 级别<br>FROM employees;</p>
<p>#二，分组数组<br>/*<br>sum ,avg.max,min,count计算个数<br>特点：<br>1，sum，avg一般用于处理数值型<br>max，min，count可以处理任何数据类型<br>2，以上分组都忽略null<br>3，可以和distinct搭配实现去重运算<br>4，一般使用count（*）用作统计函数<br>5，和分组函数一同查询的字段要求是group by后的字段<br>*/</p>
<p>#1,简单使用<br>SELECT SUM(salary) FROM employees;#691400.00其它类似</p>
<p>#2，distinct<br>SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</p>
<p>#4count<br>SELECT COUNT(<em>) FROM employees;#统计列表函数<br>SELECT COUNT(1) FROM employees;#统计列表函数<br>/</em><br>效率：<br>myisam存储引擎下，count(<em>)的效率要高<br>innodb存储引擎下，count(</em>)和count(1)效率差不多，比count（字段）要高点<br>*/</p>
<p>#6<br>SELECT AVG(salary),employee_id FROM employees;#没任何意义</p>
<p>#查询部门编号为90的员工个数<br>SELECT COUNT(*)<br>FROM employees<br>WHERE department_id = 90;</p>
<p>#进阶5：分组查询<br>/*<br>语法：<br>select  分组函数，列（要求出现在group by）的后面<br>from 表<br>【where 筛选条件】<br>group by 分组的列表<br>【order by】子句<br>注意：查询的列表必须特殊，要求是分组函数和group by后出现的字段<br>特点：<br>分组筛选分为两类<br>分组前筛选（数据前分组后的筛选集） 位置在group之前 where<br>分组后筛选（数据源分组后的筛选集）位置在group之后 having<br>分组函数（min。max等）做条件肯定是放在having语句中<br>能用分组前筛选的，就优先考虑分组前筛选<br>group by 子句支持单个字段分组，多个字段分组，表达式分组<br>也可以添加排序（排序放在分组查询的最后）<br>*/</p>
<p>#查询每个工种的最高工资<br>SELECT MAX(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p>
<p>#添加分组前筛选条件</p>
<p>#查询邮箱中包含a字符的，每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id;</p>
<p>#添加分组后的筛选</p>
<p>#查询哪个部门的员工人数&gt;2<br>SELECT COUNT(<em>),department_id<br>FROM employees<br>GROUP BY department_id<br>HAVING COUNT(</em>)&gt;2</p>
<p>#复杂案例</p>
<p>#查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p>
<p>#1，查询每个工种的有奖金的员工的最高工资<br>SELECT MAX(salary),job_id#显示的表头<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id</p>
<p>#2,筛选后工资&gt;12000<br>SELECT MAX(salary),job_id<br>FROM employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING MAX(salary)&gt;12000</p>
<p>#按表达式分组</p>
<p>#按员工姓名长度分组<br>SELECT COUNT(*),LENGTH(last_name) leng<br>FROM employees<br>GROUP BY leng;</p>
<p>#按多个字段进行分组</p>
<p>#查询每个部门每个工种的员工的平均工资<br>SELECT AVG(salary),department_id,job_id<br>FROM employees<br>GROUP BY department_id,job_id ;</p>
<p>#添加排序</p>
<p>#查询每个部门每个工种的员工的平均工资，按平均工资从高到低<br>SELECT AVG(salary),department_id,job_id<br>FROM employees<br>WHERE department_id IS NOT NULL<br>GROUP BY department_id,job_id<br>HAVING AVG(salary)&gt;10000<br>ORDER BY AVG(salary) DESC;</p>
<p>#连接查询<br>/*<br>含义：多表查询，当查询的字段来着多个表时，就会用到连接查询<br>笛卡尔现象：表一m行，表二n行，一共有m*n行<br>原因没有有效的连接<br>分类：<br>按年代分类：<br>sql192标准<br>sql199标准【推荐】：支持内连接+外连接（左外+右外）+交叉连接<br>按功能分类：<br>内连接：<br>外连接：<br>交叉连接<br>*/</p>
<p>#一，sql192标准<br>SELECT * FROM beauty;</p>
<p>#1，等值连接<br>/*<br>1,多表等值连接的结果为多表的交集部分<br>2，n表连接，至少需要n-1个连接条件<br>3，多表连接的顺序没有要求<br>4，一般需要起别名<br>5，可以搭配前面的介绍的所有子句使用，比如分组<br>*/</p>
<p>#找男朋友<br>SELECT NAME,boyname FROM boys,beauty<br>WHERE beauty.<code>boyfriend_id</code>=boys.<code>id</code>;</p>
<p>#为表起别名<br>/*<br>1.提高语句的简洁度<br>2，区分多个重名的字符<br>注意：如果为表起别名，则查询的字段就不能使用原来的表名去限定<br>*/</p>
<p>#查询员工名，工种号，工种名<br>SELECT last_name,e.<code>job_id</code>,job_title<br>FROM employees AS e,jobs#为表起别名<br>WHERE e.<code>job_id</code>=jobs.<code>job_id</code></p>
<p>#加筛选</p>
<p>#查询城市名中第二个字符为o的部门名和城市名<br>SELECT department_name,city<br>FROM departments d,locations l<br>WHERE d.location_id=l.location_id<br>AND city LIKE ‘_o%’;</p>
<p>#分组</p>
<p>#查找每个部门的部门个数吧城市显示出来<br>SELECT COUNT(*) 个数,city<br>FROM <code>departments</code> d,<code>locations</code> l<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city;</p>
<p>#排序</p>
<p>#查询每个工种的工种名和员工的个数，并且按员工个数降序<br>SELECT job_title,COUNT(<em>)<br>FROM <code>employees</code> e,<code>jobs</code> j<br>WHERE e.<code>job_id</code>=j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY COUNT(</em>) DESC;</p>
<p>#三表连接</p>
<p>#案例：查询员工名，部门名和所在的城市<br>SELECT last_name,department_name,city<br>FROM <code>locations</code> l,<code>departments</code> d,<code>employees</code> e<br>WHERE d.<code>location_id</code>=l.<code>location_id</code><br>AND e.<code>department_id</code>=d.<code>department_id</code></p>
<p>#2，非等值连接</p>
<p>#查询员工的工资和工资级别<br>SELECT salary,grade_level<br>FROM employees AS e,job_grades AS g<br>WHERE salary BETWEEN g.lowest_sal AND g.highest_sal<br>AND g.grade_level=’A’;#加个排序<br>SELECT * FROM job_grades</p>
<p>#创建等级表<br>CREATE TABLE job_grades<br>(grade_level VARCHAR(3),<br> lowest_sal  INT,<br> highest_sal INT);<br>INSERT INTO job_grades<br>VALUES (‘A’, 1000, 2999);<br>INSERT INTO job_grades<br>VALUES (‘B’, 3000, 5999);<br>INSERT INTO job_grades<br>VALUES(‘C’, 6000, 9999);<br>INSERT INTO job_grades<br>VALUES(‘D’, 10000, 14999);<br>INSERT INTO job_grades<br>VALUES(‘E’, 15000, 24999);<br>INSERT INTO job_grades<br>VALUES(‘F’, 25000, 40000);</p>
<p>#3，自连接：一张表分成两张表</p>
<p>#查询员工名和上级的名称<br>SELECT e.<code>employee_id</code>,e.<code>last_name</code>,m.<code>employee_id</code>,m.<code>last_name</code><br>FROM employees e,employees m<br>WHERE e.<code>manager_id</code>=m.<code>employee_id</code></p>
<p>#一，sql199标准<br>/*<br>语法：<br>select 查询列表<br>from 表1 别名【连接类型】<br>join 表2 别名<br>on 连接条件<br>【where 筛选条件】<br>【分组】<br>按连接类型分类：<br>内连接：inner【交集】<br>外连接：<br>1，左外 left<br>2，右外 right<br>3，全外  full<br>交叉连接 cross<br>*/</p>
<p>#一，内连<br>/*<br>语法：<br>select 查询列表<br>from 表1 别名<br>inner join 表2 别名<br>on 连接条件<br>分类：<br>等值<br>非等值<br>自连接<br>特点：<br>1，可以添加排序，筛选<br>2，inner 可以省略<br>3，筛选条件放在where后面，连接条件在on后面<br>4，最终实现效果是一样的<br>*/</p>
<p>#1，等值连接</p>
<p>#查询员工名和部门名<br>SELECT last_name,department_name<br>FROM employees e<br>INNER JOIN <code>departments</code> d<br>ON e.<code>department_id</code>=d.<code>department_id</code>;</p>
<p>#查询部门个数&gt;0的城市名和部门个数，并排序</p>
<p>#1.先查找每个部门个数</p>
<p>#2，在此条件上加筛选<br>SELECT city,COUNT(<em>) 部门个数<br>FROM <code>departments</code>d<br>INNER JOIN <code>locations</code> l<br>ON d.<code>location_id</code>=l.<code>location_id</code><br>GROUP BY city<br>HAVING COUNT(</em>)&gt;0<br>ORDER BY COUNT(*) DESC;</p>
<p>#三表连接</p>
<p>#查询员工名，部门名和工种名，并按部门名降序<br>SELECT <code>department_name</code>,<code>job_title</code>,<code>last_name</code><br>FROM <code>employees</code> e<br>INNER JOIN <code>departments</code> d ON e.<code>department_id</code>=d.<code>department_id</code><br>INNER JOIN jobs j ON e.<code>job_id</code> =j.<code>job_id</code><br>ORDER BY department_name DESC;</p>
<p>#2，非等值连接</p>
<p>#查询员工的工资和工资级别<br>SELECT salary,grade_level<br>FROM employees AS e<br>JOIN job_grades AS g<br>ON e.salary BETWEEN g.lowest_sal AND g.highest_sal<br>AND g.grade_level=’A’;#加个排序</p>
<p>#3，自连接：一张表分成两张表</p>
<p>#查询姓名包含k的员工名和上级的名称<br>SELECT e.<code>employee_id</code>,e.<code>last_name</code>,m.<code>employee_id</code>,m.<code>last_name</code><br>FROM employees e<br>JOIN employees m<br>ON e.<code>manager_id</code>=m.<code>employee_id</code><br>WHERE e.<code>last_name</code> LIKE ‘%k%’;</p>
<p>#二，外连接【一个表里有，另一个表没有】<br>/*<br>特点：<br>1，外连接查询结果为主表的所有记录<br>如果从表有与他匹配的。则显示出来<br>没有则显示null<br>外连接查询结果=内连接查询结果+主表中有而从表没有的记录<br>2,左外连接。left左边的是主表<br>右外连接。right右边的是主表<br>3，左外和右外可以实现同样的效果<br>4,全外连接=内连接+表1有但表2没有+表2有表1没有【mysql不支持】<br>*/</p>
<p>#引入：查询男朋友，不在男神表的女神名<br>SELECT b.name<br>FROM <code>beauty</code> b<br>LEFT JOIN <code>boys</code> bo<br>ON b.<code>boyfriend_id</code>=bo.<code>id</code><br>WHERE bo.<code>id</code> IS  NULL;</p>
<p>#三交叉连接【实现笛卡尔乘积】<br>SELECT b.<em>,bo.</em><br>FROM <code>beauty</code> b<br>CROSS JOIN <code>boys</code> bo;</p>
<p>#sql192和199</p>
<p>#功能：sq199支持较多</p>
<p>#可读性：sql199实现连接条件额筛选条件的分离，可读性较高</p>
<p>#子查询<br>/*<br>含义：<br>出现在其他语句中的select语句，称为子查询或内查询<br>外部的查询语句，称为主查询或外查询<br>分类：<br>按子查询的出现的位置：<br>select后面：<br>标量子查询（结果集只有一行一列）<br>from后面：<br>表子查询（结果集只有多行多列）<br>where或having后面 重点<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集只有一行多列）<br>exists后面<br>表子查询（结果集只有多行多列）<br>按结果集的行列数不同：<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集只有一行多列）<br>表子查询（结果集只有多行多列）<br>*/</p>
<p>#一，where或having后面 重点<br>/*<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集只有一行多列）<br>特点：<br>1，子查询都在小括号内<br>2，子查询都放在条件右侧<br>3，标量字查询，一般搭配单行操作符使用</p>
<blockquote>
<p>&lt;==&gt;&lt;<br>列子查询，一般搭配多行操作符使用<br>in,any/some,all<br>4,子查询优先于主查询<br>*/</p>
</blockquote>
<p>#1,标量子查询</p>
<p>#谁的工资比Abel高</p>
<p>#1，查询Abel工资<br>SELECT salary<br>FROM <code>employees</code><br>WHERE last_name=’Abel’;</p>
<p>#2,查询员工信息，满足其条件<br>SELECT *<br>FROM <code>employees</code><br>WHERE salary&gt;(<br>    SELECT salary<br>    FROM <code>employees</code><br>    WHERE last_name=’Abel’<br>);</p>
<p>#返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</p>
<p>#1，查询141job_id<br>SELECT job_id<br>FROM <code>employees</code><br>WHERE employee_id=141;</p>
<p>#2,查询143的salary<br>SELECT salary<br>FROM <code>employees</code><br>WHERE employee_id=143;</p>
<p>#3，两个要求嵌套<br>SELECT last_name,job_id,salary<br>FROM <code>employees</code><br>WHERE job_id=(<br>    SELECT job_id<br>    FROM <code>employees</code><br>    WHERE employee_id=141<br>)<br>AND salary &gt;(<br>SELECT salary<br>FROM <code>employees</code><br>WHERE employee_id=143<br>);</p>
<p>#返回公司工资最少的员工的last_name,job_id和salary</p>
<p>#1,查询工资最小的<br>SELECT MIN(salary)<br>FROM <code>employees</code></p>
<p>#2,返回last_name,job_id和salary<br>SELECT last_name,job_id,salary<br>FROM <code>employees</code><br>WHERE salary=(<br>    SELECT MIN(salary)<br>    FROM <code>employees</code><br>);</p>
<p>#查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<p>#1,50号部门的最低工资<br>SELECT MIN(salary)<br>FROM <code>employees</code><br>WHERE <code>department_id</code>=50;</p>
<p>#2,各部门的最低工资<br>SELECT MIN(salary),<code>department_id</code><br>FROM <code>employees</code><br>GROUP BY<code>department_id</code>;</p>
<p>#3筛选2，满足min(salary)&gt;1<br>SELECT MIN(salary),<code>department_id</code><br>FROM <code>employees</code><br>GROUP BY<code>department_id</code><br>HAVING MIN(salary)&gt;<br>(<br>    SELECT MIN(salary)<br>    FROM <code>employees</code><br>    WHERE <code>department_id</code>=50<br>)<br>;</p>
<p>#非法使用标量子查询</p>
<p>#列子查询</p>
<p>#返回location_id是1400或1700的部门中的所有员工姓名</p>
<p>#1，location_id是1400或1700的部门编号<br>SELECT DISTINCT department_id<br>FROM <code>departments</code><br>WHERE location_id IN (1400,1700);</p>
<p>#2查询所有员工姓名<br>SELECT last_name<br>FROM <code>employees</code><br>WHERE department_id IN(<br>    SELECT DISTINCT department_id<br>    FROM <code>departments</code><br>    WHERE location_id IN (1400,1700)<br>);</p>
<p>#行子查询</p>
<p>#查询员工编号最小工资最高的员工信息</p>
<p>#1，查询员工最小的员工编号<br>SELECT MIN(employee_id)<br>FROM <code>employees</code>;</p>
<p>#1，查询工资最高的员工编号<br>SELECT MAX(salary)<br>FROM <code>employees</code>;</p>
<p>#3,查询员工信息<br>SELECT *<br>FROM <code>employees</code><br>WHERE employee_id=(<br>SELECT MIN(employee_id)<br>FROM <code>employees</code><br>)<br>AND<br> salary=(<br> SELECT MAX(salary)<br>FROM <code>employees</code>);</p>
<p>#——————————-</p>
<p>#另一种方法<br>SELECT *<br>FROM <code>employees</code><br>WHERE (employee_id,salary)=(<br>    SELECT MIN(employee_id),MAX(salary)<br>    FROM <code>employees</code><br>);</p>
<p>#select后面：</p>
<p>#标量子查询（结果集只有一行一列）</p>
<p>#查询每个部门的员工个数<br>SELECT d.<em>,(<br>SELECT COUNT(</em>)#结果集只有一行一列<br>FROM <code>employees</code> e<br>WHERE e.<code>department_id</code>=d.<code>department_id</code><br>) 员工<br>FROM <code>employees</code> d;</p>
<p>#from后面：</p>
<p>#表子查询（结果集只有多行多列）<br>/*<br>将子查询的结果充当一张表，要求必须起别名<br>*/</p>
<p>#查询每个部门的平均工资的工资等级</p>
<p>#1,查询每个部门的平均工资<br>SELECT AVG(salary),department_id<br>FROM <code>employees</code><br>GROUP BY <code>department_id</code></p>
<p>#2,连接1的结果集和job_grade表。筛选条件在最低和最高工资之间<br>SELECT ag_dep.*,g.grade_level<br>FROM<br>(<br>    SELECT AVG(salary) ag,department_id<br>    FROM <code>employees</code><br>    GROUP BY <code>department_id</code><br>) ag_dep<br>INNER JOIN job_grades g<br>ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</p>
<p>#exists后面 </p>
<p>#表子查询（结果集只有多行多列）<br>/*<br>语法：<br>exists(完整的查询语句)<br>结果：1或0<br>*/<br>SELECT EXISTS (SELECT <code>employee_id</code> FROM <code>employees</code>);</p>
<p>#查询有员工名的部门名<br>SELECT department_name<br>FROM <code>departments</code> d<br>WHERE EXISTS (<br>SELECT *<br>FROM <code>employees</code> e<br>WHERE d.<code>department_id</code>=e.<code>department_id</code><br>);</p>
<p>#—————-</p>
<p>#另一种<br>SELECT department_name<br>FROM <code>departments</code> d<br>WHERE d.<code>department_id</code> IN(<br>    SELECT <code>department_id</code><br>    FROM <code>employees</code><br>);</p>
<p>#分页查询<br>/*<br>应用场景：<br>当要显示的数据，一页显示不全，需要分页提交sql请求<br>语法：<br>select 查询列表<br>from 表<br>【join type join 表 2<br>on 连接条件<br>where 筛选条件<br>group by<br>having<br>order by<br>】<br>limit 【offset ,】size;<br>offset：索引开始【从0开始】<br>size;要显示的条目个数<br>特点：<br>1，limit 语句放查询语句的最后<br>2，公式<br>select 查询列表<br>from 列表<br>limit (page-1)*size,size;<br>*/</p>
<p>#查询前11到15条员工信息<br>SELECT * FROM <code>employees</code> LIMIT 10,15;</p>
<p>#有奖金员工信息，并把前十名显示出来<br>SELECT *<br>FROM <code>employees</code><br>WHERE <code>commission_pct</code> IS NOT NULL<br>ORDER BY <code>salary</code> DESC<br>LIMIT 10;</p>
<p>#联合查询<br>/*<br>union 联合，合并：将多条查询语句合并成一个结果<br>语法：<br>查询语句1<br>union<br>查询语句2<br>….<br>查询语句n<br>应用场景：<br>要查询的结果来自于多个表，且多个表没有直接连接关系，但查询的信息一致时<br>特点：<br>1，要求多条查询的语句的查询列数一致<br>2，查询顺序一致<br>3，union关键字默认去重，使用union all可以包含重复项<br>*/</p>
<p>#查询部门编号&gt;90或邮箱包含a的员工信息<br>SELECT * FROM <code>employees</code> WHERE <code>email</code> LIKE ‘%a&amp;’ OR <code>department_id</code>&gt;90;<br>SELECT * FROM <code>employees</code> WHERE <code>email</code> LIKE ‘%a&amp;’<br>UNION<br>SELECT * FROM <code>employees</code> WHERE <code>department_id</code>&gt;90;</p>
<p>#DML语言<br>/*<br>数据操作语言<br>插入：insert<br>修改：update<br>删除：delete<br>*/</p>
<p>#一，插入语句<br>/*<br>语法一:<br>insert into 表名(列名….) value（值1,…);<br>*/<br>SELECT * FROM <code>beauty</code>;</p>
<p>#1,插入数据类型一致<br>INSERT INTO <code>beauty</code>(<code>id</code>,<code>name</code>,<code>sex</code>,<code>borndate</code>,<code>phone</code>,<code>photo</code>,<code>boyfriend_id</code>)<br>VALUE(13,’hhu’,’女’,’1900-9-00’,’1898888888’,NULL,2);</p>
<p>#2,不可以为null必须插入列，可以的null可以不写<br>INSERT INTO <code>beauty</code>(<code>id</code>,<code>name</code>,<code>sex</code>,<code>phone</code>)<br>VALUE(14,’hhu’,’女’,’1898888888’);</p>
<p>#3.列的顺序可以调换，但必须一一对立</p>
<p>#4.列数和值的个数必须一致</p>
<p>#5，可以省略列名，默认所有列，而且列的顺序和原来的顺序一致<br>INSERT INTO <code>beauty</code><br>VALUE(15,’hhu’,’女’,’1900-9-00’,’1898888888’,NULL,2);<br>/*<br>语法二:<br>insert into 表名(列名….)<br>set 列名=值，列名=值,….<br>*/<br>INSERT INTO <code>beauty</code><br>SET id=17,<code>name</code>=’nv’,phone=’184017777’;</p>
<p>#两种方式pk</p>
<p>#方式一支持插入多行<br>INSERT INTO <code>beauty</code>(<code>id</code>,<code>name</code>,<code>sex</code>,<code>borndate</code>,<code>phone</code>,<code>photo</code>,<code>boyfriend_id</code>)<br>VALUE(23,’hhu1’,’女’,’1900-9-00’,’1898888888’,NULL,2),<br>(24,’hhu2’,’女’,’1900-9-00’,’1898888888’,NULL,2),<br>(25,’hhu3’,’女’,’1900-9-00’,’1898888888’,NULL,2);</p>
<p>#方式一支持子查询，方式二不支持<br>INSERT INTO <code>beauty</code>(<code>id</code>,<code>name</code>,<code>sex</code>,<code>phone</code>)<br>SELECT 26,’hhu’,’女’,’1898888888’ ;</p>
<p>#二，修改语句<br>/*<br>1，修改单表的记录<br>语法：<br>update表名  1<br>set 列=新值，列=新值  3<br>where 筛选条件  2<br>2，修改多表<br>语法：<br>sql192：<br>update 表1 别名，表2 别名<br>set 列=值<br>where 连接条件<br>and 筛选条件<br>sql199：<br>update 表1 别名<br>Inner|left|rihgt join 表2  别名<br>on 连接条件<br>set 列=值<br>where 筛选条件<br>*/</p>
<p>#1，修改单表的记录</p>
<p>#修改boys表中id为2的值名称为张飞魅力值为10<br>SELECT * FROM <code>boys</code>;<br>UPDATE <code>boys</code><br>SET <code>boyName</code>=’张飞’,<code>userCP</code>=10<br>WHERE id=2;</p>
<p>#2，修改多表</p>
<p>#修改张无忌的女朋友的手机号为114<br>UPDATE <code>boys</code> bo<br>INNER JOIN <code>beauty</code> b<br>ON bo.<code>id</code>=b.<code>boyfriend_id</code><br>SET b.<code>phone</code>=114<br>WHERE bo.<code>boyName</code>=’张无忌’;</p>
<p>#三，删除语句<br>/*<br>方式一delete<br>语法：<br>1，单表删除<br>delete from 表名 where 筛选条件<br>2多表删除<br>sql192：<br>delete 表1的别名，表2的别名<br>from 表1 别名，表2 别名<br>where 连接条件<br>and 筛选条件<br>sql199：<br>delete 表1的别名，表2的别名<br>from 表1 别名，表2 别名<br>Inner|left|rihgt join 表2  别名<br>on 连接条件<br>where 筛选条件<br>方式二：truncate<br>语法：truncate table 表【不允许where】<br>*/</p>
<p>#方式一 删除</p>
<p>#1，单表删除</p>
<p>#以9结尾的女神信息<br>DELETE FROM <code>beauty</code> WHERE <code>phone</code> LIKE ‘%9’;<br>SELECT * FROM <code>beauty</code>;</p>
<p>#删除张无忌女朋友的信息<br>DELETE b<br>FROM <code>beauty</code> b<br>INNER JOIN <code>boys</code> bo<br>ON b.<code>boyfriend_id</code>=bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’张无忌’;</p>
<p>#删除黄晓明和她女朋友的信息<br>DELETE b,bo<br>FROM <code>beauty</code> b<br>INNER JOIN <code>boys</code> bo<br>ON b.<code>boyfriend_id</code>=bo.<code>id</code><br>WHERE bo.<code>boyName</code>=’黄晓明’;</p>
<p>#方式二：truncate<br>TRUNCATE TABLE <code>boys</code>；<br>/*<br>delete和truncate区别<br>1，truncate不允许where<br>2，truncate效率高<br>3，假如要删除自增长列<br>delete删除，再插入数据，从断点开始<br>truncate删除再插入数据，从0开始<br>4，truncate 删除没有返回值，delete删除有返回值<br>5，truncate删除不能回滚，delete删除可以<br>*/</p>
<p>#DDL<br>/*<br>数据定义语言<br>一，库的管理<br>二，表的管理<br>创建：create<br>修改alter<br>删除drop<br>*/</p>
<p>#一，库的管理</p>
<p>#1，库的创建<br>/*语法：<br>create database[IS NOT EXISTS] 库名；<br>*/</p>
<p>#案例：创建books<br>CREATE DATABASE IF NOT EXISTS books;#只能执行一次</p>
<p>#2,库的修改</p>
<p>#更改库的字符集<br>ALTER DATABASE books CHARACTER SET gbk;</p>
<p>#3，库的删除<br>DROP DATABASE IF EXISTS books;</p>
<p>#二表的管理</p>
<p>#1.表的创建<br>/*<br>语法：<br>create table 表名(<br>    列名 列的类型【(长度) 约束】，<br>    列名 列的类型【(长度) 约束】，<br>    列名 列的类型【(长度) 约束】，<br>    ….<br>    列名 列的类型【(长度) 约束】，<br>)<br>*/</p>
<p>#案例，创建book<br>CREATE TABLE book(<br>    id INT,<br>    bname VARCHAR(20),<br>    price DOUBLE,<br>    authorid INT,<br>    publishdate DATETIME<br>);<br>DESC book;</p>
<p>#案例，创建author<br>CREATE TABLE author(<br>    id INT,<br>    auname VARCHAR(20),<br>    nation VARCHAR(10)<br>);<br>DESC author;</p>
<p>#2.表的修改</p>
<p>#1，修改表的列名<br>ALTER TABLE book CHANGE COLUMN publishdate pubdate DATETIME;</p>
<p>#2,列的类型<br>ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</p>
<p>#3，添加新列<br>ALTER TABLE author ADD annual DOUBLE;</p>
<p>#4，删除列<br>ALTER TABLE DROP ADD annual;</p>
<p>#5，修改表名<br>ALTER TABLE author RENAME TO book_author;</p>
<p>#3.表的删除<br>DROP TABLE book_author;<br>SHOW TABLES;</p>
<p>#通用的写法<br>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名；<br>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE 新表名；</p>
<p>#4.表的复制<br>INSERT INTO author VALUES<br>(1,’chun’,’ri’),<br>(2,’xia’,’ch’);<br>SELECT * FROM author;</p>
<p>#1,仅仅复制表的结构<br>CREATE TABLE author1 LIKE author;</p>
<p>#2,复制表的结构和数据<br>CREATE TABLE author2 SELECT * FROM author;<br>SELECT * FROM author2;</p>
<p>#3,只复制部分数据<br>CREATE TABLE author3<br>SELECT id,auname<br>FROM author<br>WHERE nation=’ch’;<br>SELECT * FROM author3;</p>
<p>#4,复制部分结构<br>CREATE TABLE author4<br>SELECT id,auname<br>FROM author<br>WHERE 0;<br>SELECT * FROM author4;</p>
<p>#常见数据类型<br>/*<br>数值型：<br>整型:<br>小数：<br>    定点数<br>    浮点数<br>字符型：<br>较短的文本：<br>较长的文本：<br>日期型：<br>*/</p>
<p>#一，整型<br>/*<br>1,如果不设置无符号和有符号，默认有符号，设置无符号要UNSIGNED<br>2，如果插入数值超出整数范围，会报outofrange，并插入临界值<br>3，如果不设置长度，会有默认长度<br>长度代表显示的最大宽度，如果不够会用01在左边填充，但必须搭配zerofull使用<br>*/</p>
<p>#1，如何设置无符号和有符号<br>DROP TABLE IF EXISTS tab_int;<br>CREATE TABLE tab_int(<br>    t1 INT,<br>    t2 INT UNSIGNED<br>);<br>DESC tab_int;#查看表的结构</p>
<p>#二，浮点型<br>/*<br>分类：<br>1，浮点型<br>float(m,d)<br>double(m,d)<br>2，定点型<br>dec(m,d)<br>特点：<br>1，<br>m：整数部分+小数部分<br>d:小数部分<br>如果超出范围，则插入临界值<br>2，m和d都可以省略<br>如果是dec，m默认10，d默认0.<br>如果是float，double，则无所谓<br>3，定点型的精确值较高（货币运算）<br>*/<br>CREATE TABLE tab_float(<br>    f1 FLOAT(5,2),<br>    f2 DOUBLE(5,2),<br>    f3 DEC(5,2)<br>);</p>
<p>#原则<br>/*<br>所选择的类型越简单越好，所保存的数值类型越小越好<br>*/</p>
<p>#三，字符型：<br>/*<br>较短的文本：<br>char（m）<br>varchar（m）<br>比较<br>char：固定长度字符,m可省略，默认为1，最大字符数<br>varchar：可变长度字符，m不可省略，最大字符数<br>其他：<br>binary用于保存较短的二进制<br>enum：保存枚举<br>set：保存集合<br>较长的文本：<br>*/</p>
<p>#四，日期型<br>/*<br>DATETIME:字节8，不受时区的影响<br> TIMESTAMP：字节4，受时区的影响<br>*/<br>CREATE TABLE tab_date(<br>    t1 DATETIME,<br>    t2 TIMESTAMP<br>);<br>INSERT INTO tab_date VALUES (NOW(),NOW());<br>SELECT * FROM tab_date;<br>SHOW VARIABLES LIKE ‘time_zone’;<br>SET time_zone=’+9:00’;</p>
<p>#常见约束<br>/*<br>含义：一种限制，用于限制表中的数据，为了保证表中的准确和可靠性<br>分类：<br> not null ：非空约束（姓名）<br> dffault:默认约束（性别）<br> primary key：唯一约束+非空约束 比如学号、员工编号等【主键】<br> UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空<br> check：检查约束（年龄，性别）【mysql不支持】<br> foreign key：用于限制两个表的关系，在从表的添加外键约束，用于引用于主表的某列的值<br> 添加约束的时间：<br> 1，设计表的时候<br> 2，需要修改表时<br> 约束的添加分类：<br> 列级约束：<br> 六大约束都可以支持，除了外键约束<br> 表级约束<br> 除了非空和默认，其他都支持<br> 主键和唯一的大对比：<br>        保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合<br>    主键    √        ×        至多有1个           √，但不推荐<br>    唯一    √        √        可以有多个          √，但不推荐<br>外键：<br>    1、要求在从表设置外键关系<br>    2、从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求<br>    3、主表的关联列必须是一个key（一般是主键或唯一）<br>    4、插入数据时，先插入主表，再插入从表<br>    删除数据时，先删除从表，再删除主表<br>*/<br>CREATE TABLE 表名(<br>    字段名 字段类型 列的约束，<br>    表级约束<br>)</p>
<p>#一、创建表时添加约束</p>
<p>#1.添加列级约束<br>/*<br>语法：<br>直接在字段名和类型后面追加 约束类型即可。<br>只支持：默认、非空、主键、唯一<br>*/<br>CREATE DATABASE students;<br>USE students;</p>
<p>#DROP TABLE stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT PRIMARY KEY,#主键<br>    stuName VARCHAR(20) NOT NULL UNIQUE,#非空<br>    gender CHAR(1) CHECK(gender=’男’ OR gender =’女’),#检查【不支持】<br>    seat INT UNIQUE,#唯一<br>    age INT DEFAULT  18,#默认约束<br>    majorId INT REFERENCES major(id)#外键【不支持】<br>);<br>CREATE TABLE major(<br>    id INT PRIMARY KEY,<br>    majorName VARCHAR(20)<br>);</p>
<p>#查看stuinfo中的所有索引，包括主键、外键、唯一<br>SHOW INDEX FROM stuinfo;</p>
<p>#2.添加表级约束<br>/*<br>语法：在各个字段的最下面<br> 【constraint 约束名】 约束类型(字段名)<br>*/<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT,<br>    CONSTRAINT pk PRIMARY KEY(id),#主键<br>    CONSTRAINT uq UNIQUE(seat),#唯一键<br>    CONSTRAINT ck CHECK(gender =’男’ OR gender  = ‘女’),#检查<br>    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键<br>);<br>SHOW INDEX FROM stuinfo;</p>
<p>#通用的写法：##<br>CREATE TABLE IF NOT EXISTS stuinfo(<br>    id INT PRIMARY KEY,<br>    stuname VARCHAR(20),<br>    sex CHAR(1),<br>    age INT DEFAULT 18,<br>    seat INT UNIQUE,<br>    majorid INT,<br>    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br>);</p>
<p>#二、修改表时添加约束<br>/*<br>1、添加列级约束<br>alter table 表名 modify column 字段名 字段类型 新约束;<br>2、添加表级约束<br>alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;<br>*/<br>DROP TABLE IF EXISTS stuinfo;<br>CREATE TABLE stuinfo(<br>    id INT,<br>    stuname VARCHAR(20),<br>    gender CHAR(1),<br>    seat INT,<br>    age INT,<br>    majorid INT<br>)<br>DESC stuinfo;</p>
<p>#1.添加非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</p>
<p>#2.添加默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</p>
<p>#3.添加主键</p>
<p>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</p>
<p>#②表级约束<br>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p>
<p>#4.添加唯一</p>
<p>#①列级约束<br>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</p>
<p>#②表级约束<br>ALTER TABLE stuinfo ADD UNIQUE(seat);</p>
<p>#5.添加外键<br>ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </p>
<p>#三、修改表时删除约束</p>
<p>#1.删除非空约束<br>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</p>
<p>#2.删除默认约束<br>ALTER TABLE stuinfo MODIFY COLUMN age INT ;</p>
<p>#3.删除主键<br>ALTER TABLE stuinfo DROP PRIMARY KEY;</p>
<p>#4.删除唯一<br>ALTER TABLE stuinfo DROP INDEX seat;</p>
<p>#5.删除外键<br>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br>SHOW INDEX FROM stuinfo;</p>
<p>#标识列 AUTO_INCREMENT<br>/*<br>又称为自增长列<br>含义：可以不用手动的插入值，系统提供默认的序列值<br>特点：<br>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？至多一个！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 SET auto_increment_increment=3;设置步长<br>可以通过 手动插入值，设置起始值<br>*/</p>
<p>#一、创建表时设置标识列<br>DROP TABLE IF EXISTS tab_identity;<br>CREATE TABLE tab_identity(<br>    #id INT  UNIQUE AUTO_INCREMENT,<br>    id INT,<br>    NAME FLOAT ,<br>    seat INT</p>
<p>);<br>TRUNCATE TABLE tab_identity;<br>INSERT INTO tab_identity(id,NAME) VALUES(NULL,’john’);<br>SELECT * FROM tab_identity;<br>SHOW VARIABLES LIKE ‘%auto_increment%’;#【设置起始值（mysql不支持）和步长】<br>SET auto_increment_increment=3;#【设置步长】</p>
<p>#二、修改表时设置标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</p>
<p>#三、修表时删除标识列<br>ALTER TABLE tab_identity MODIFY COLUMN id INT;</p>
<p>#TCL<br>/*<br>事务：事务由单独单元的一个或多个SQL语句组成，在这<br>个单元中，每个MySQL语句是相互依赖的。而整个单独单 元<br>作为一个不可分割的整体，如果单元中某条SQL语句一<br>旦执行失败或产生错误，整个单元将会回滚。所有受到影<br>响的数据将返回到事物开始以前的状态；如果单元中的所<br>有SQL语句均执行成功，则事物被顺利执行。<br>事务特性：<br>原子性：事务是一个不可分割的工作单位，事务中的操作要么 都发生，要么都不发生<br>一致性：使数据库从一个一致性状态变换到另外一个一致性状态 。<br>隔离性：指一个事务的执行不能被其他事务干扰<br>持久性：一个事务一旦被提交，它对数据库中数据的改变就是 永久性的<br>事务的创建<br>隐式事务：事务没有明显的开启和结束标识<br>比如:insert,delete<br>显式事务：<br>事务具有明显的开启和结束标记<br>前提：必须先设置自动提交功能为禁用<br>set autocommit =0;<br>步骤1：<br>set autocommit =0;<br>start transaction;可选的<br>步骤二：编写事务中的sql语句（select insert update delete）【create不可用】<br>语句1<br>语句2<br>步骤3：结束事务<br>commit提交事务<br>rollback;回滚事务【二选一】：不改变原始数据<br>savepoint 节点名：设置保护点<br>事务隔离级别:<br>read uncommitted：会脏读，会不可重复读，会幻读<br>read committed：不会脏读，会不可重复读，会幻读<br>repeatable read不会脏读，不会不可重复读，会幻读<br>serializable不会脏读，不会不可重复读，不会幻读<br>Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。<br>Oracle 默认的事务隔离级别为: READ COMMITED<br>Mysql 支持 4 种事务隔离级别. Mysql 默认的事务隔离级别<br>为: REPEATABLE READ</p>
<p>#看ppt<br>*/</p>
<p>#delete和truncate在事务使用时的区别</p>
<p>#演示delete<br>SET autocommit =0;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;</p>
<p>#演示truncate【不支持回滚】<br>SET autocommit =0;<br>START TRANSACTION;<br>TRUNCATE TABLE account;<br>ROLLBACK;</p>
<p>#视图<br>/*<br>含义：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据<br>比如：舞蹈班和普通班级的对比<br>    创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view        只是保存了sql逻辑    增删改查，只是一般不能增删改<br>表    create table        保存了数据        增删改查<br>*/</p>
<p>#一、创建视图<br>/*<br>语法：<br>create view 视图名<br>as<br>查询语句;<br>*/<br>USE myemployees;</p>
<p>#1.查询姓名中包含a字符的员工名、部门名和工种信息</p>
<p>#①创建<br>CREATE VIEW myv1<br>AS<br>SELECT last_name,department_name,job_title<br>FROM employees e<br>JOIN departments d ON e.department_id  = d.department_id<br>JOIN jobs j ON j.job_id  = e.job_id;</p>
<p>#②使用<br>SELECT * FROM myv1 WHERE last_name LIKE ‘%a%’;</p>
<p>#2.查询各部门的平均工资级别</p>
<p>#①创建视图查看每个部门的平均工资<br>CREATE VIEW myv2<br>AS<br>SELECT AVG(salary) ag,department_id<br>FROM employees<br>GROUP BY department_id;</p>
<p>#②使用<br>SELECT myv2.<code>ag</code>,g.grade_level<br>FROM myv2<br>JOIN job_grades g<br>ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code> AND g.<code>highest_sal</code>;</p>
<p>#3.查询平均工资最低的部门信息<br>SELECT * FROM myv2 ORDER BY ag LIMIT 1;</p>
<p>#4.查询平均工资最低的部门名和工资<br>CREATE VIEW myv3<br>AS<br>SELECT * FROM myv2 ORDER BY ag LIMIT 1;<br>SELECT d.*,m.ag<br>FROM myv3 m<br>JOIN departments d<br>ON m.<code>department_id</code>=d.<code>department_id</code>;</p>
<p>#二、视图的修改</p>
<p>#方式一：<br>/*<br>create or replace view  视图名<br>as<br>查询语句;<br>*/<br>SELECT * FROM myv3<br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT AVG(salary),job_id<br>FROM employees<br>GROUP BY job_id;</p>
<p>#方式二：<br>/*<br>语法：<br>alter view 视图名<br>as<br>查询语句;<br>*/<br>ALTER VIEW myv3<br>AS<br>SELECT * FROM employees;</p>
<p>#三、删除视图<br>/*<br>语法：drop view 视图名,视图名,…;【要求有权限，我们新建的root是最高权限】<br>*/<br>DROP VIEW emp_v1,emp_v2,myv3;</p>
<p>#四、查看视图<br>DESC myv3;<br>SHOW CREATE VIEW myv3;【命令行查询比较全】</p>
<p>#五、视图的更新<br>DROP VIEW <code>myv1</code>,<code>myv2</code>,<code>myv3</code>;#删除视图<br>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;<br>CREATE OR REPLACE VIEW myv1<br>AS<br>SELECT last_name,email<br>FROM employees;<br>SELECT * FROM myv1;<br>SELECT * FROM employees;</p>
<p>#1.插入【视图和原表都修改了】<br>INSERT INTO myv1 VALUES(‘张飞’,‘zf@qq.com’);</p>
<p>#2.修改【视图和原表都修改了】<br>UPDATE myv1 SET last_name = ‘张无忌’ WHERE last_name=’张飞’;</p>
<p>#3.删除【视图和原表都修改了】<br>DELETE FROM myv1 WHERE last_name = ‘张无忌’;</p>
<p>#具备以下特点的视图不允许更新</p>
<p>#①包含以下关键字的sql语句：分组函数、</p>
<p>#distinct、group  by、having、union或者union all</p>
<p>#②常量视图<br>CREATE OR REPLACE VIEW myv2<br>AS<br>SELECT ‘john’ NAME;<br>SELECT * FROM myv2;</p>
<p>#更新<br>UPDATE myv2 SET NAME=’lucy’;【更新失败】</p>
<p>#③Select中包含子查询<br>CREATE OR REPLACE VIEW myv3<br>AS<br>SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资<br>FROM departments;</p>
<p>#更新【更新失败】<br>SELECT * FROM myv3;<br>UPDATE myv3 SET 最高工资=100000;</p>
<p>#④join</p>
<p>#⑤from一个不能更新的视图</p>
<p>#⑥where子句的子查询引用了from子句中的表</p>
<p>#查询所有领导的信息<br>CREATE OR REPLACE VIEW myv6<br>AS<br>SELECT last_name,email,salary<br>FROM employees<br>WHERE employee_id IN(<br>    SELECT  manager_id<br>    FROM employees<br>    WHERE manager_id IS NOT NULL<br>);</p>
<p>#更新【更新失败】<br>SELECT * FROM myv6;<br>UPDATE myv6 SET salary=10000 WHERE last_name = ‘k_ing’;</p>
<p>#变量<br>/*<br>系统变量：<br>    全局变量<br>    会话变量<br>自定义变量：<br>    用户变量<br>    局部变量<br>*/</p>
<p>#一、系统变量<br>/*<br>说明：变量由系统定义，不是用户定义，属于服务器层面<br>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br>使用步骤：<br>1、查看所有系统变量<br>show global|【session】variables;<br>2、查看满足条件的部分系统变量<br>show global|【session】 variables like ‘%char%’;<br>3、查看指定的系统变量的值<br>select @@global|【session】系统变量名;<br>4、为某个系统变量赋值<br>方式一：<br>set global|【session】系统变量名=值;<br>方式二：<br>set @@global|【session】系统变量名=值;<br>*/</p>
<p>#1》全局变量<br>/*<br>作用域：针对于所有会话（连接）有效，但不能跨重启<br>跨重启【要改配置文件】<br>*/#①查看所有全局变量<br>SHOW GLOBAL VARIABLES;</p>
<p>#②查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE ‘%char%’;</p>
<p>#③查看指定的系统变量的值<br>SELECT @@global.autocommit;</p>
<p>#④为某个系统变量赋值【跨连接有效】<br>SET @@global.autocommit=0;<br>SET GLOBAL autocommit=0;</p>
<p>#2》会话变量<br>/*<br>作用域：针对于当前会话（连接）有效<br>*/</p>
<p>#①查看所有会话变量【SESSION省略效果一样，默认会话变量】<br>SHOW SESSION VARIABLES;</p>
<p>#②查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE ‘%char%’;</p>
<p>#③查看指定的会话变量的值<br>SELECT @@autocommit;<br>SELECT @@session.tx_isolation;</p>
<p>#④为某个会话变量赋值<br>SET @@session.tx_isolation=’read-uncommitted’;<br>SET SESSION tx_isolation=’read-committed’;</p>
<p>#二、自定义变量<br>/*<br>说明：变量由用户自定义，而不是系统提供的<br>使用步骤：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）<br>*/</p>
<p>#1》用户变量<br>/*<br>作用域：针对于当前会话（连接）有效，作用域同于会话变量<br>*/</p>
<p>#赋值操作符：=或:=</p>
<p>#①声明并初始化<br>SET @变量名=值;<br>SET @变量名:=值;<br>SELECT @变量名:=值;</p>
<p>#②赋值（更新变量的值）</p>
<p>#方式一：【不需要加类型】<br>    SET @变量名=值;<br>    SET @变量名:=值;<br>    SELECT @变量名:=值;<br>    #案例<br>    SET @name=’join’;<br>    SET @name=1;<br>    SET @count=1;</p>
<p>#方式二：<br>    SELECT 字段 INTO @变量名<br>    FROM 表;<br>    #案例<br>    SELECT COUNT(*) INTO @count<br>    FROM <code>employees</code>;#把employees数据放入count中</p>
<p>#③使用（查看变量的值）<br>SELECT @变量名;</p>
<p>#案例<br>SELECT  @count;</p>
<p>#2》局部变量<br>/*<br>作用域：仅仅在定义它的begin end块中有效<br>应用在 begin end中的第一句话<br>*/</p>
<p>#①声明<br>DECLARE 变量名 类型;<br>DECLARE 变量名 类型 【DEFAULT 值】;</p>
<p>#②赋值（更新变量的值）</p>
<p>#方式一：<br>    SET 局部变量名=值;<br>    SET 局部变量名:=值;<br>    SELECT 局部变量名:=值;</p>
<p>#方式二：<br>    SELECT 字段 INTO 具备变量名<br>    FROM 表;</p>
<p>#③使用（查看变量的值）<br>SELECT 局部变量名;</p>
<p>#用户变量和局部变量的对比<br>        作用域            定义位置        语法<br>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p>
<p>#案例：声明两个变量，求和并打印</p>
<p>#用户变量<br>SET @m=1;<br>SET @n=2;<br>SET @sum=@m+@n;<br>SELECT @sum;</p>
<p>#局部变量【需要在BEGIN END中】<br>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 1;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p>
<p>#存储过程和函数<br>/*<br>存储过程和函数：类似于java中的方法<br>好处：<br>1、提高代码的重用性<br>2、简化操作<br>*/</p>
<p>#存储过程<br>/*<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>*/</p>
<p>#一、创建语法<br>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN#相当于普通的大括号{<br>    存储过程体（一组合法的SQL语句）<br>END#相当于普通的大括号}</p>
<p>#注意：<br>/*<br>1、参数列表包含三部分<br>参数模式  参数名  参数类型【比java多了参数模式】<br>举例：<br>in stuname varchar(20)<br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值<br>2、如果存储过程体仅仅只有一句话，begin end可以省略<br>存储过程体中的每条sql语句的结尾要求必须加分号。<br>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记<br>案例：<br>delimiter $<br>*/</p>
<p>#二、调用语法<br>CALL 存储过程名(实参列表);</p>
<p>#1.空参列表</p>
<p>#案例：插入到admin表中五条记录<br>SELECT * FROM admin;<br>DELIMITER $<br>CREATE PROCEDURE myp1()<br>BEGIN<br>    INSERT INTO admin(username,<code>password</code>)<br>    VALUES(‘john1’,’0000’),(‘lily’,’0000’),(‘rose’,’0000’),(‘jack’,’0000’),(‘tom’,’0000’);<br>END $</p>
<p>#调用<br>CALL myp1()$</p>
<p>#2.创建带in模式参数的存储过程</p>
<p>#案例1：创建存储过程实现 根据女神名，查询对应的男神信息<br>CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.*<br>    FROM boys bo<br>    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>    WHERE b.name=beautyName;<br>END $</p>
<p>#调用<br>CALL myp2(‘小昭’)$</p>
<p>#案例2 ：创建存储过程实现，用户是否登录成功<br>CREATE PROCEDURE myp3(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))<br>BEGIN<br>    DECLARE result INT DEFAULT 0;#声明并初始化<br>    SELECT COUNT(*) INTO result#赋值给result<br>    FROM admin<br>    WHERE admin.username = username<br>    AND admin.password = PASSWORD;<br>    SELECT IF(result&gt;0,’成功’,’失败’);#使用【大于0成功，小于0失败】<br>END $</p>
<p>#调用<br>CALL myp3(‘张飞’,’8888’)$</p>
<p>#3.创建out 模式参数的存储过程</p>
<p>#案例1：根据输入的女神名，返回对应的男神名【一个out】<br>CREATE PROCEDURE myp5(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))<br>BEGIN<br>    SELECT bo.boyname INTO boyname#赋值<br>    FROM boys bo<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = bo.id<br>    WHERE b.name=beautyName ;<br>END $</p>
<p>#调用<br>CALL myp5(‘小昭’,@name)$<br>SELECT @name$</p>
<p>#案例2：根据输入的女神名，返回对应的男神名和魅力值【多个out】<br>CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT)<br>BEGIN<br>    SELECT boys.boyname ,boys.usercp INTO boyname,usercp<br>    FROM boys<br>    RIGHT JOIN<br>    beauty b ON b.boyfriend_id = boys.id<br>    WHERE b.name=beautyName ;<br>END $</p>
<p>#调用<br>CALL myp6(‘小昭’,@name,@cp)$<br>SELECT @name,@cp$</p>
<p>#4.创建带inout模式参数的存储过程</p>
<p>#案例1：传入a和b两个值，最终a和b都翻倍并返回<br>CREATE PROCEDURE myp7(INOUT a INT ,INOUT b INT)<br>BEGIN<br>    SET a=a<em>2;<br>    SET b=b</em>2;<br>END $</p>
<p>#调用<br>SET @m=10$<br>SET @n=20$<br>CALL myp7(@m,@n)$<br>SELECT @m,@n$</p>
<p>#三、删除存储过程</p>
<p>#语法：drop procedure 存储过程名<br>DROP PROCEDURE myp2;<br>DROP PROCEDURE myp2,myp3;#×【只能一次删除一个】</p>
<p>#四、查看存储过程的信息<br>DESC myp3;×#【错误，仅仅用于视图和表】<br>SHOW CREATE PROCEDURE  myp3;</p>
<p>#五、修改存储过程【删了重新写，内部不能修改】</p>
<p>#函数<br>/*<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>区别：<br>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果<br>*/</p>
<p>#一、创建语法<br>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型<br>BEGIN<br>    函数体<br>END<br>/*<br>注意：<br>1.参数列表 包含两部分：<br>参数名 参数类型<br>2.函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>return 值;<br>3.函数体中仅有一句话，则可以省略begin end<br>4.使用 delimiter语句设置结束标记<br>*/</p>
<p>#二、调用语法<br>SELECT 函数名(参数列表)#执行完返回返回值<br>1.无参有返回</p>
<p>#案例：返回公司的员工个数<br>USE <code>myemployees</code>$<br>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>    DECLARE c INT DEFAULT 0;#定义局部变量<br>    SELECT COUNT(*) INTO c#赋值<br>    FROM employees;<br>    RETURN c;<br>END $<br>SELECT myf1()$</p>
<p>#2.有参有返回</p>
<p>#案例1：根据员工名，返回它的工资<br>CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    SET @sal=0;#定义用户变量<br>    SELECT salary INTO @sal   #赋值<br>    FROM employees<br>    WHERE last_name = empName;<br>    RETURN @sal;<br>END $#返回两个值会报错<br>SELECT myf2(‘Kochar’) $</p>
<p>#案例2：根据部门名，返回该部门的平均工资<br>CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>    DECLARE sal DOUBLE ;<br>    SELECT AVG(salary) INTO sal<br>    FROM employees e<br>    JOIN departments d ON e.department_id = d.department_id<br>    WHERE d.department_name=deptName;<br>    RETURN sal;<br>END $<br>SELECT myf3(‘IT’)$</p>
<p>#三、查看函数<br>SHOW CREATE FUNCTION myf3;</p>
<p>#四、删除函数<br>DROP FUNCTION myf3;</p>
<p>#案例</p>
<p>#一、创建函数，实现传入两个float，返回二者之和<br>CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>    DECLARE SUM FLOAT DEFAULT 0;#设置默认值为0<br>    SET SUM=num1+num2;<br>    RETURN SUM;<br>END $<br>SELECT test_fun1(1,2)$</p>
<p>#流程控制结构<br>/*<br>顺序、分支、循环<br>*/</p>
<p>#一、分支结构</p>
<p>#1.if函数<br>/*<br>语法：if(条件,值1，值2)<br>功能：实现双分支<br>应用在begin end中或外面<br><em>/<br>2.case结构<br>/</em><br>语法：<br>情况1：类似于switch<br>case 变量或表达式<br>when 值1 then 语句1;<br>when 值2 then 语句2;<br>…<br>else 语句n;<br>end<br>情况2：类似多重if<br>case<br>when 条件1 then 语句1;<br>when 条件2 then 语句2;<br>…<br>else 语句n;<br>end<br>特点：<br>1，<br>作为表达式，应用在begin end 中或外面<br>作为独立语句使用，只能用于begin end 中<br>2，执行中，如果when中的语句成立就执行then后的语句，然后跳出<br>并结束case<br>3，else省略，其他when不瞒足，则返回null<br>*/</p>
<p>#案例1：创建存储过程，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D<br>CREATE PROCEDURE test_case(IN score INT)<br>BEGIN<br>    CASE<br>    WHEN score&gt;=90 AND score&lt;=100 THEN SELECT ‘A’;<br>    WHEN score&gt;=80 THEN SELECT ‘B’;<br>    WHEN score&gt;=70 THEN SELECT ‘C’;<br>    ELSE SELECT ‘D’;<br>    END CASE;<br>END $<br>CALL test_case(87)$</p>
<p>#3.if结构<br>/*<br>语法：<br>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>….<br>else 语句n;<br>end if;<br>功能：类似于多重if<br>只能应用在begin end 中<br>*/</p>
<p>#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D<br>CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR<br>BEGIN<br>    DECLARE ch CHAR DEFAULT ‘A’;<br>    IF score&gt;90 THEN SET ch=’A’;<br>    ELSEIF score&gt;80 THEN SET ch=’B’;<br>    ELSEIF score&gt;60 THEN SET ch=’C’;<br>    ELSE SET ch=’D’;<br>    END IF;<br>    RETURN ch;<br>END $<br>SELECT test_if(87)$</p>
<p>#二、循环结构<br>/*<br>分类：<br>while、loop、repeat<br>循环控制：<br>iterate类似于 continue，继续，结束本次循环，继续下一次<br>leave 类似于  break，跳出，结束当前所在的循环<br>*/</p>
<p>#1.while<br>/*<br>语法：<br>【标签:】while 循环条件 do<br>    循环体;<br>end while【 标签】;<br>联想：<br>while(循环条件){<br>    循环体;<br>}<br>*/</p>
<p>#2.loop<br>/*<br>语法：<br>【标签:】loop<br>    循环体;<br>end loop 【标签】;<br>可以用来模拟简单的死循环<br>*/</p>
<p>#3.repeat<br>/*<br>语法：<br>【标签：】repeat<br>    循环体;<br>until 结束循环的条件<br>end repeat 【标签】;<br>*/</p>
<p>#1.没有添加循环控制语句</p>
<p>#案例：批量插入，根据次数插入到admin表中多条记录<br>DROP PROCEDURE pro_while1$<br>/*<br>int i=1;<br>while(i&lt;=insertcount){<br>    //插入<br>    i++;<br>}<br>*/<br>USE <code>girls</code>$<br>CREATE PROCEDURE pro_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘Rose’,i),’666’);<br>        SET i=i+1;<br>    END WHILE;<br>END $<br>CALL pro_while1(100)$</p>
<p>#2.添加leave语句[【添加循环控制】</p>
<p>#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止<br>TRUNCATE TABLE admin$#【清空表】<br>DROP PROCEDURE test_while1$#【清空存储】<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 1;<br>    a:WHILE i&lt;=insertCount DO<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘xiaohua’,i),’0000’);<br>        IF i&gt;=20 THEN LEAVE a;#a是标签<br>        END IF;<br>        SET i=i+1;<br>    END WHILE a;<br>END $<br>CALL test_while1(100)$</p>
<p>#3.添加iterate语句</p>
<p>#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次<br>TRUNCATE TABLE admin$<br>DROP PROCEDURE test_while1$<br>CREATE PROCEDURE test_while1(IN insertCount INT)<br>BEGIN<br>    DECLARE i INT DEFAULT 0;<br>    a:WHILE i&lt;=insertCount DO<br>        SET i=i+1;<br>        IF MOD(i,2)!=0 THEN ITERATE a;#求余<br>        END IF;<br>        INSERT INTO admin(username,<code>password</code>) VALUES(CONCAT(‘xiaohua’,i),’0000’);<br>    END WHILE a;<br>END $<br>CALL test_while1(100)$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/22/4day/" data-id="cjzm3l9il0000popkw4z6cyug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/08/20/thirdtry/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">【学习向】（图文详解）美化个人csdn和个人网页博客</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/22/4day/">【学习向 】mysql基础知识整理</a>
          </li>
        
          <li>
            <a href="/2019/08/20/thirdtry/">【学习向】（图文详解）美化个人csdn和个人网页博客</a>
          </li>
        
          <li>
            <a href="/2019/08/20/secondtry/">【详细介绍】如何hexo+github搭建自己的个人博客</a>
          </li>
        
          <li>
            <a href="/2019/08/10/firsttry/">【知识向】如何上传文件到github和ssh配置</a>
          </li>
        
          <li>
            <a href="/2019/08/10/hello-world/">你好，世界！我来了</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>